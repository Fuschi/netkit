% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/cluster_signed_louvain.R
\name{cluster_signed_louvain}
\alias{cluster_signed_louvain}
\title{Community Detection in Signed Weighted Graphs (Gómez Modularity)}
\usage{
cluster_signed_louvain(g, resistance = 0, penalty = 1, add.names = FALSE)
}
\arguments{
\item{g}{An \code{igraph} object representing a weighted and undirected graph.
Edge weights can be positive or negative.}

\item{resistance}{Numeric; simulates a uniform self-loop resistance applied to all nodes.
Default is \code{0}, corresponding to no resistance.}

\item{penalty}{Non-negative numeric; controls the weight of the null model term.
Higher values tend to produce larger communities.}

\item{add.names}{Logical; if \code{TRUE} and vertex names exist, they are
assigned to the membership vector. Default is \code{FALSE}.}
}
\value{
An object of class \code{communities} (from \pkg{igraph}), with components:
\itemize{
\item \code{membership}: a vector assigning each vertex to a community.
\item \code{modularity}: the optimized signed modularity score \eqn{Q = Q^{+} - Q^{-}}.
\item \code{algorithm}: the label \code{"signed modularity louvain"}.
}
}
\description{
Detects communities in signed weighted graphs by optimizing the signed modularity
proposed by Gómez, Jensen, and Arenas (2009). This function wraps an external
executable that implements the signed modularity Louvain-like optimization,
capable of handling both positive and negative edge weights in undirected networks.

The signed modularity is defined as:
\deqn{Q = Q^{+} - Q^{-}}
where \eqn{Q^{+}} represents the modularity for positive edges and
\eqn{Q^{-}} for negative edges (treated as repulsive interactions).
}
\details{
The algorithm identifies dense subgraphs by maximizing the difference between the
modularity of positive and negative edge weights. It is particularly suitable for
correlation or association networks where links can represent both cooperative and
antagonistic relationships.

Internally, the function:
\enumerate{
\item Writes the graph to a temporary file in Pajek (\code{.net}) format.
\item Invokes the appropriate executable for the host operating system.
\item Parses the output to build a standard \code{communities} object from \pkg{igraph}.
}

The required executables must be present in the \code{exec/} directory of the package:
\itemize{
\item \code{gomez_modularity_opt_Linux.exe} — Linux version
\item \code{gomez_modularity_opt_Mac.exe} — macOS version
\item \code{gomez_modularity_opt_Windows.exe} — Windows version
}

At runtime, they are automatically located using:
\code{system.file("exec", package = "netkit")}

Each executable must support the following command-line interface:
\preformatted{
  <executable> none WS l 1 <resistance> <penalty> <input_file> <output_file>
}
}
\note{
Temporary files (\code{.net} and \code{_res.txt}) are written to \code{tempdir()}
and automatically deleted after execution.
}
\section{Executables}{

The external binaries are distributed under the package’s \code{exec/} directory.
Ensure they are executable (use \code{chmod +x} on Unix-like systems).
These files are not compiled by R; they must be pre-built for each OS.
}

\examples{
library(igraph)
g <- make_ring(10)
E(g)$weight <- rnorm(ecount(g), mean = 0, sd = 1)

# Run community detection
comm <- cluster_signed_louvain(g)

# Inspect results
membership(comm)
modularity(comm)
plot(comm, g)

}
\references{
Gómez, S., Jensen, P., & Arenas, A. (2009). Analysis of community structure in networks
of correlated data. \emph{Physical Review E}, 80(1), 016114.
\doi{10.1103/PhysRevE.80.016114}
}
\seealso{
\code{\link[igraph]{communities}}, \code{\link[igraph]{make_clusters}},
\code{\link[igraph]{cluster_spinglass}}
}
